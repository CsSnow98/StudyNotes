# 20220303 学习笔记

---

## 工作
信通院整理表格，甘特图做法

## 刷题
### 哈希表
1. 赎金信
   * 两个hashmap篮子
2. 三数之和
   * 三指针做法
3. 四数之和
   * 在三数之和上加一层循环，同三指针
4. 总结
   * 数组做哈希表 数据有限
   * set做哈希表
   * map做哈希表 需要记录的值多
### 字符串
1. 反转字符串
   * 双指针做法
2. 反转字符串II
   * 双指针定义reverse函数
   * 按位置交换
3. 替换空格
   * 遍历重新生成string
4. 翻转字符串里的单词
   * 快慢指针去多余的空格
   * 翻转字符串再翻转字符
5. 左旋转字符串
   * 三次翻转
6. 实现strStr()
   * **经典KMP算法** 优化点在于字符串不匹配时，返回的匹配位置。
   *  求next数组，相当于字符串前缀和后缀匹配
   *  j = -1 用 j + 1 匹配，j = ne[j]； j = 0 用 j 匹配，j = ne[j - 1]； 
7. 重复的子字符串
   *  结论：如果len % (len - (next[len - 1] + 1)) == 0 ，则说明 (数组长度-最长相等前后缀的长度) 正好可以被 数组的长度整除，说明有该字符串有重复的子字符串。
   *  kmp算法求前后缀
8. 总结
   * 双指针做法   数组，链表和字符串常用。
   * 反转系列
   * KMP
### 栈与队列
1. 栈与队列基础
   栈先进后出，队列先进先出
   栈和队列都是容器适配器，底层可用多种容器实现
2. 用栈实现队列
   * 两个栈，一个进一个出
3. 用队列实现栈
   * 两个队列，一个进出，一个备份
   * 一个队列，循环进出
4. 有效的括号
   * 用栈匹配
5. 删除字符串中的所有相邻重复项
   * 用栈做“消消乐”
6. 逆波兰表达式求值
   * 用栈重复操作，数字弹入，操作符弹出操作弹入
7. 滑动窗口最大值
   * 单调队列，存索引需严格单调，存值不需要严格单调
8. 前k个高频元素
   * hashmap存频次
   * 优先队列小根堆对频次排序
   * 弹出队列顶元素返回
9. 总结
   * stack，queue，deque，priority_queue
   * 滑动窗口最大/小值即单调队列  
    

## 知识
### c++
1. reverse用法  
   reverse函数功能是逆序（或反转），多用于字符串、数组、容器。头文件是 `#include <algorithm>`

    reverse函数用于反转在[first,last)范围内的顺序（包括first指向的元素，不包括last指向的元素），reverse函数无返回值

    ```
    string str="hello world , hi";
    reverse(str.begin(),str.end());//str结果为 ih , dlrow olleh
    vector<int> v = {5,4,3,2,1};
    reverse(v.begin(),v.end());//容器v的值变为1,2,3,4,5
    ```
2. 优先队列，大小根堆定义
    ```
    #include <queue>
    priority_queue<int> pq1 // 大根堆
    priority_queue<int, vector<int>, greater<int>> pq2 // 小根堆
    ```
    自定义 
    ```
    struct cmp {bool operator()(int a,int b) {return a > b;}}; // 自定义小根堆
    priority_queue<int, vector<int>, cmp> pq;
    ```
3. sort用法  
   sort函数用于C++中，对给定区间所有元素进行排序。头文件是`#include <algorithm>`。

    实现原理：sort并不是简单的快速排序，它对普通的快速排序进行了优化，此外，它还结合了插入排序和堆排序。系统会根据你的数据形式和数据量自动选择合适的排序方法，这并不是说它每次排序只选择一种方法，它是在一次完整排序中不同的情况选用不同方法，比如给一个数据量较大的数组排序，开始采用快速排序，分段递归，分段之后每一段的数据量达到一个较小值后它就不继续往下递归，而是选择插入排序，如果递归的太深，他会选择堆排序。

    `sort(first_pointer,first_pointer+n,cmp)`

    此函数有3个参数：

    第一个参数是要排序的数组的起始地址。
    第二个参数是结束的地址(最后一位要排序的地址的下一地址)
    第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。
    如果要改为从大到小排序，需要加一个函数compare。