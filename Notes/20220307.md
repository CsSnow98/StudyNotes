# 20220307笔记

***


## 刷题
### 二叉树
1.  从中序与后序遍历序列构造二叉树
    * 利用中序和后序序列分别分割
    * 后序序列分割出根节点，中序序列分割出左右孩子。
    * 函数参数和返回值
    两个数组，返回根节点
    * 结束条件
    数组长度为1
    * 单层逻辑
    在后序序列寻找根节点，分割中序序列，左孩子等于递归左区间（若存在），右孩子等于递归右区间（若存在），返回根节点。
2.  最大二叉树
    * 函数参数和返回值
    数组，返回根节点
    * 结束条件
    数组长度为1
    * 单层逻辑
    数组最大值为根节点，根据索引划分数组，左孩子等于递归左数组（若存在），右孩子等于递归右数组（若存在），返回根节点
3.  周末总结

4.  合并二叉树
    * 函数参数和返回值
    两个根节点 返回合并后的树
    * 结束条件
    两个节点都为空 返回空节点  
    哪个节点存在，返回哪个节点 
    * 单层逻辑   
    都存在，两个节点值相加
    左孩子等于递归左孩子
    右孩子等于递归右孩子
    返回根节点
5.  二叉搜索树中的搜索
    * 函数参数和返回值
    根节点和key，返回符合条件的子树
    * 结束条件
    节点为空，返回null
    * 单层逻辑
    大于，返回递归右孩子
    小于，返回递归左孩子
    返回节点
6.  验证二叉搜索树
    * 迭代中序遍历，前后节点比较
7.  二叉搜索树的最小绝对差
    * 迭代中序遍历，前后节点做差，维护差的绝对值最小值
8.  二叉搜索树中的众数
    * 迭代中序遍历，统计出现次数，等于最大结果就加入，大于最大结果就清空再加入。
9.  二叉树的最近公共祖先
    * 函数参数和返回值
    两个节点，返回祖先
    * 结束条件
    节点等于q或p或空，返回root
    * 单层逻辑
    如果递归左存在，递归右存在，返回root
    如果递归左存在，返回左
    如果递归右存在，返回右
    返回空

10. **二叉树周末总结**
    搜索一条边的写法：
    ```
    if (递归函数(root->left)) return ;

    if (递归函数(root->right)) return ;
    ```
    搜索整个树写法：
    ```
    left = 递归函数(root->left);
    right = 递归函数(root->right);
    ```
    left与right的逻辑处理;
    看出区别了没？

    在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后续还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）。

    **再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：**

    如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
    如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍）
    如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）
    而本题我们要找一条符合条件的路径，所以递归函数需要返回值，及时返回
11. 二叉树的直径
    * 函数参数和返回值
    root 和 深度
    * 结束条件
    空节点 返回0
    * 单层逻辑
    左边深度，右边深度，求直径和最大值比对并更新，返回当前深度。
12. 环形链表
    * 快慢指针
13. 多数元素
    * hashmap
14. 只出现一次的数字
    * 异或的交换性
    * 一个数和本身异或值为0
15. 相交链表
    * 走相同距离，走到头相互掉头
16. 买卖股票的最佳时机
    * 单调队列 可用vector实现
17. 最小栈
    * 维护备用栈
18. 回文链表
    * 变成数组，从中间向两边比对
    * 快慢指针，慢指针同时翻转链表，快指针到位开始比对。
19. 比特位计数
    * `a & (a - 1)`消除a最近的1 计数
20. 找到所有数组中消失的数字
    * 用自身作为hash表
21. 汉明距离
    * 先异或
    * `a & (a - 1)`消除a最近的1 计算距离
22. 搜索旋转排序数组

## 知识
